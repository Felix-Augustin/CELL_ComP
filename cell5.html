<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- 强制刷新时间戳 -->
    <meta name="timestamp" content="2025-06-27-14:30:00">
    <meta name="version" content="FINAL-FIX-v2.0">
    
    <title>细胞结构3D可视化平台 v2.0</title>
    
    <!-- 页面加载前的紧急拦截脚本 -->
    <script>
        // 紧急拦截 - 在任何其他脚本之前执行
        console.log('🚨 紧急拦截器启动 - 时间:', new Date().toISOString());
        
        // 立即检查URL是否包含intro
        if (window.location.href.includes('intro')) {
            console.error('🚫 检测到URL中包含intro，强制重定向');
            window.location.replace(window.location.href.split('?')[0]);
        }
        
        // 清理可能的缓存
        if (window.caches) {
            caches.keys().then(names => {
                names.forEach(name => {
                    if (name.includes('intro')) {
                        caches.delete(name);
                        console.log('🗑️ 删除缓存:', name);
                    }
                });
            });
        }
    </script>
    
    <!-- 立即执行的缓存清理脚本 -->
    <script>
        // === 终极强制重置和清理系统 ===
        console.clear(); // 清理控制台
        console.log('🔄 === 细胞结构3D可视化平台 v2.0 启动 ===');
        console.log('🚨 执行强制缓存清理和错误修复...');
        
        // 添加时间戳确保这是最新版本
        console.log('⏰ 当前时间:', new Date().toISOString());
        console.log('📝 版本:', '2025-06-27-FINAL');
        
        // 立即清理所有存储
        try {
            localStorage.clear();
            sessionStorage.clear();
            // 额外清理可能的缓存键
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.includes('video') || key.includes('intro')) {
                    localStorage.removeItem(key);
                }
            }
            console.log('✅ 存储彻底清理完成');
        } catch(e) {
            console.log('⚠️ 存储清理失败:', e);
        }
        
        // === 超级强化网络请求拦截器 ===
        
        // 拦截所有可能的网络请求方式
        const blockedPaths = ['intro1.mp4', 'intro2.mp4', 'intro3.mp4', 'intro4.mp4'];
        
        // 1. 拦截 fetch 请求
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            const url = args[0];
            const urlString = typeof url === 'string' ? url : url.url || url.href || '';
            
            for (const blocked of blockedPaths) {
                if (urlString.includes(blocked)) {
                    console.error('🚫 FETCH请求已被拦截:', urlString);
                    return Promise.reject(new Error('请求被安全策略阻止: ' + urlString));
                }
            }
            return originalFetch.apply(this, args);
        };
        
        // 2. 拦截 XMLHttpRequest
        const originalXHR = window.XMLHttpRequest;
        window.XMLHttpRequest = function() {
            const xhr = new originalXHR();
            const originalOpen = xhr.open;
            xhr.open = function(method, url, ...args) {
                const urlString = typeof url === 'string' ? url : '';
                for (const blocked of blockedPaths) {
                    if (urlString.includes(blocked)) {
                        console.error('🚫 XHR请求已被拦截:', urlString);
                        throw new Error('请求被安全策略阻止: ' + urlString);
                    }
                }
                return originalOpen.apply(this, [method, url, ...args]);
            };
            return xhr;
        };
        
        // 3. 拦截 createElement 中的媒体元素
        const originalCreateElement = document.createElement;
        document.createElement = function(tagName) {
            const element = originalCreateElement.call(this, tagName);
            if (tagName.toLowerCase() === 'video' || tagName.toLowerCase() === 'audio') {
                const originalSetAttribute = element.setAttribute;
                element.setAttribute = function(name, value) {
                    if (name === 'src' && typeof value === 'string') {
                        for (const blocked of blockedPaths) {
                            if (value.includes(blocked)) {
                                console.error('🚫 媒体元素src设置已被拦截:', value);
                                return; // 阻止设置
                            }
                        }
                    }
                    return originalSetAttribute.call(this, name, value);
                };
                
                // 拦截直接的src属性设置
                Object.defineProperty(element, 'src', {
                    set: function(value) {
                        if (typeof value === 'string') {
                            for (const blocked of blockedPaths) {
                                if (value.includes(blocked)) {
                                    console.error('🚫 媒体元素src属性设置已被拦截:', value);
                                    return; // 阻止设置
                                }
                            }
                        }
                        // 使用反射设置原始属性
                        element.setAttribute('src', value);
                    },
                    get: function() {
                        return element.getAttribute('src');
                    }
                });
            }
            return element;
        };
        
        console.log('🚫 已部署三层intro*.mp4文件访问拦截器');
        console.log('✅ 只允许访问animation/animation.mp4');
        
        // 4. 监控所有网络活动（开发者工具）
        if (window.performance && window.performance.getEntriesByType) {
            setInterval(() => {
                const resources = window.performance.getEntriesByType('resource');
                resources.forEach(resource => {
                    if (resource.name.includes('intro') && resource.name.includes('.mp4')) {
                        console.error('🚨 检测到intro类视频文件网络请求:', resource.name);
                        console.error('🚨 这不应该发生！请检查浏览器缓存。');
                    }
                });
            }, 1000);
        }
        
        // 5. 添加全局错误处理器
        window.addEventListener('error', function(event) {
            if (event.filename && event.filename.includes('intro') && event.filename.includes('.mp4')) {
                console.error('🚨 检测到intro类视频文件错误:', event.filename);
                event.preventDefault();
                return false;
            }
        });
        
        // 6. 强制重置video元素
        document.addEventListener('DOMContentLoaded', function() {
            const videos = document.querySelectorAll('video');
            videos.forEach(video => {
                video.src = '';
                video.load();
                video.pause();
                console.log('🔄 重置video元素:', video.id || 'unnamed');
            });
        });
        
        // 清理Service Worker（仅在HTTPS环境下运行）
        if ('serviceWorker' in navigator && location.protocol === 'https:') {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    registration.unregister();
                    console.log('🗑️ 注销Service Worker:', registration.scope);
                }
            }).catch(function(error) {
                console.log('⚠️ Service Worker清理失败（本地文件正常）:', error.message);
            });
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.js"></script>
    <!-- BioDigital API - 使用官方推荐的v3.0.0 -->
    <script src="https://developer.biodigital.com/builds/api/human-api-3.0.0.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #09375C, #3DA4E6, #95D4F3);
        }
        
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #09375C, #2B313F);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        #intro-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(9, 55, 92, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1001;
        }
        
        #platform-title {
            color: #F9F2E0;
            text-align: center;
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.5s ease;
            margin-bottom: 30px;
        }
        
        #platform-title.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        #enter-button {
            margin-top: 20px;
            padding: 20px 40px;
            font-size: 18px;
            background: rgba(249, 242, 224, 0.15);
            color: #F9F2E0;
            border: 2px solid rgba(249, 242, 224, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.4s ease;
            opacity: 0;
            transform: translateY(20px);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        #enter-button.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        #enter-button:hover {
            background: rgba(249, 242, 224, 0.25);
            border-color: rgba(249, 242, 224, 0.6);
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }
        
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #E3E3E5, #C6E6E8);
        }
        
        #control-panel {
            width: 300px;
            padding: 20px;
            background: linear-gradient(135deg, #F9F2E0, #F7ECE7);
            box-shadow: 0 0 20px rgba(9, 55, 92, 0.2);
            overflow-y: auto;
            z-index: 10;
            border-right: 3px solid #1660AB;
        }
        
        #render-container {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, #95D4F3, #3DA4E6, #09375C);
        }
        
        h1, h2, h3 {
            color: #2B313F;
        }
        
        h1 {
            color: #A61B29;
            border-bottom: 3px solid #A61B29;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #1660AB;
            border-bottom: 2px solid #1660AB;
            padding-bottom: 8px;
        }
        
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            border-left: 4px solid #1660AB;
            backdrop-filter: blur(5px);
        }
        
        .feature-list {
            list-style-type: none;
            padding: 0;
        }
        
        .feature-list li {
            padding: 8px 0;
            border-bottom: 1px dashed #eee;
        }
        
        .common {
            color: #2ecc71;
        }
        
        .difference {
            color: #e74c3c;
        }
        
        .slider-container {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            border-left: 3px solid #3DA4E6;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #2B313F;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #95D4F3, #3DA4E6, #09375C);
            outline: none;
        }
        
        .cell-label {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: bold;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            color: #333;
            border: 2px solid #007acc;
        }
        
        .info-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 380px;
            height: 100vh;
            background: linear-gradient(135deg, #F9F2E0, #E2E7BF);
            box-shadow: -5px 0 25px rgba(9, 55, 92, 0.3);
            z-index: 1000;
            padding: 25px;
            overflow-y: auto;
            transition: right 0.4s ease;
            border-left: 3px solid #1660AB;
        }
        
        .info-panel.open {
            right: 0;
        }
        
        .info-panel h2 {
            color: #A61B29;
            border-bottom: 3px solid #A61B29;
            padding-bottom: 12px;
            text-shadow: 0 2px 4px rgba(166, 27, 41, 0.2);
        }
        
        .info-panel h3 {
            color: #1660AB;
            margin-top: 20px;
        }
        
        .info-panel h4 {
            color: #2B313F;
            margin-top: 15px;
        }
        
        .comparison-button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: linear-gradient(135deg, rgba(22, 96, 171, 0.1), rgba(226, 231, 191, 0.3));
            border: 2px solid #1660AB;
            border-radius: 12px;
            cursor: pointer;
            text-align: left;
            font-weight: bold;
            transition: all 0.3s ease;
            color: #2B313F;
            backdrop-filter: blur(5px);
        }
        
        .comparison-button:hover {
            background: linear-gradient(135deg, rgba(22, 96, 171, 0.2), rgba(226, 231, 191, 0.5));
            border-color: #A61B29;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(22, 96, 171, 0.3);
        }
        
        .comparison-button.active {
            background: linear-gradient(135deg, #1660AB, #3DA4E6);
            color: #F9F2E0;
            border-color: #09375C;
            box-shadow: 0 8px 25px rgba(9, 55, 92, 0.4);
        }
        
        .sub-buttons {
            display: none;
            margin-top: 10px;
            padding-left: 20px;
            background: rgba(247, 236, 231, 0.2);
            border-radius: 8px;
            padding: 10px;
        }
        
        .sub-buttons.show {
            display: block;
        }
        
        .sub-button {
            padding: 10px 15px;
            margin: 5px 0;
            background: linear-gradient(135deg, #707899, #373834);
            color: #F9F2E0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: block;
            width: 100%;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .sub-button:hover {
            background: linear-gradient(135deg, #A61B29, #707899);
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(166, 27, 41, 0.3);
        }
        
        .sub-button.active {
            background: linear-gradient(135deg, #A61B29, #2B313F);
            box-shadow: 0 6px 20px rgba(166, 27, 41, 0.4);
        }
        
        @media (max-width: 768px) {
            #container {
                flex-direction: column;
            }
            
            #control-panel {
                width: 100%;
                height: 40vh;
                overflow-y: scroll;
            }
            
            #render-container {
                height: 60vh;
            }
            
            .info-panel {
                width: 90%;
                right: -90%;
            }
        }
        
        .toggle-button {
            padding: 10px 15px;
            margin: 5px;
            background: linear-gradient(135deg, #3DA4E6, #95D4F3);
            color: #09375C;
            border: 2px solid #1660AB;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .toggle-button.active {
            background: linear-gradient(135deg, #1660AB, #09375C);
            color: #F9F2E0;
            box-shadow: 0 4px 15px rgba(9, 55, 92, 0.4);
        }
        
        .toggle-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(61, 164, 230, 0.3);
        }

        /* 信息面板样式 */
        .info-panel {
            background: linear-gradient(135deg, rgba(9, 55, 92, 0.15), rgba(166, 27, 41, 0.1));
            border: 1px solid rgba(249, 242, 224, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .info-panel p {
            margin: 5px 0;
            color: #F9F2E0;
            font-size: 14px;
            opacity: 0.9;
        }

        /* 隐藏BioDigital模型中的错误提示和弹窗 */
        #biodigital-prokaryotic-cell iframe {
            pointer-events: auto;
        }
        
        /* 确保BioDigital容器覆盖任何可能的弹窗 */
        #biodigital-prokaryotic-cell {
            isolation: isolate;
        }

        /* 隐藏可能的BioDigital错误弹窗（如果有的话）*/
        .biodigital-error-popup,
        .human-loading-screen,
        .human-error-message {
            display: none !important;
            visibility: hidden !important;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <!-- 视频加载界面 -->
    <div id="video-container">
        <!-- 视频播放器 -->
        <video id="intro-video" autoplay muted>
            <!-- 动态加载视频源 -->
            您的浏览器不支持视频播放
        </video>
        
        <!-- 覆盖层 -->
        <div id="video-overlay">
            <div id="loading-indicator" style="color: #F9F2E0; font-size: 18px; margin-bottom: 20px; opacity: 1;">
                正在检测文件... (animation.mp4缺失，将跳过开场动画)
            </div>
            <h1 id="platform-title">细胞结构3D可视化平台</h1>
            <button id="enter-button">进入主界面</button>
        </div>
    </div>
    
    <!-- 主界面 -->
    <div id="container" style="display: none;">
        <div id="control-panel">
            <h1>细胞结构对比</h1>
            
            <div class="section">
                <h2>特性对比</h2>
                
                <button class="comparison-button" data-type="common">
                    共有特性 ▼
                </button>
                <div class="sub-buttons" data-parent="common">
                    <button class="sub-button" data-feature="cell-membrane">细胞膜（质膜）</button>
                    <button class="sub-button" data-feature="cytoplasm">细胞质基质</button>
                    <button class="sub-button" data-feature="ribosomes">核糖体</button>
                    <button class="sub-button" data-feature="dna">DNA遗传物质</button>
                    <button class="sub-button" data-feature="metabolism">代谢活动</button>
                </div>
                
                <button class="comparison-button" data-type="differences">
                    主要区别 ▼
                </button>
                <div class="sub-buttons" data-parent="differences">
                    <button class="sub-button" data-feature="cell-wall">细胞壁结构</button>
                    <button class="sub-button" data-feature="nucleus">细胞核</button>
                    <button class="sub-button" data-feature="organelles">膜性细胞器</button>
                    <button class="sub-button" data-feature="size">细胞大小</button>
                    <button class="sub-button" data-feature="complexity">结构复杂度</button>
                </div>
            </div>
            
            <div class="section">
                <h2>模型控制</h2>
                
                <div class="slider-container">
                    <label for="opacity-slider">整体透明度</label>
                    <input type="range" id="opacity-slider" class="slider" min="0" max="1" step="0.1" value="1">
                </div>
                
                <div class="button-group">
                    <button class="toggle-button active" data-cell="prokaryotic" data-part="all">原核细胞 (BioDigital)</button>
                    <button class="toggle-button active" data-cell="eukaryotic" data-part="all">真核细胞</button>
                </div>
                

                
                <h3>原核细胞结构 (BioDigital专业模型)</h3>
                <div class="info-panel">
                    <p>🔬 左侧显示的是专业级BioDigital原核细胞模型</p>
                    <p>✨ 具有高精度3D可视化和交互功能</p>
                </div>
                
                <h3>真核细胞结构</h3>
                <div class="button-group">
                    <button class="toggle-button active" data-cell="eukaryotic" data-part="cellMembrane">细胞膜</button>
                    <button class="toggle-button active" data-cell="eukaryotic" data-part="nucleus">细胞核</button>
                    <button class="toggle-button active" data-cell="eukaryotic" data-part="mitochondria">线粒体</button>
                    <button class="toggle-button active" data-cell="eukaryotic" data-part="endoplasmicReticulum">内质网</button>
                    <button class="toggle-button active" data-cell="eukaryotic" data-part="golgiApparatus">高尔基体</button>
                    <button class="toggle-button active" data-cell="eukaryotic" data-part="lysosomes">溶酶体</button>
                </div>
            </div>
            
            <div class="section">
                <h2>细胞信息</h2>
                <div id="cell-info">
                    <p>点击细胞结构查看详细信息</p>
                </div>
            </div>
        </div>
        
        <div id="render-container"></div>
        
        <!-- 右侧信息面板 -->
        <div id="info-panel" class="info-panel">
            <h2 id="info-title">结构详情</h2>
            <div id="info-content">
                <p>选择左侧按钮查看详细信息</p>
            </div>
        </div>
    </div>

    <script>
        console.log('🔬 细胞结构3D可视化平台启动中...');
        console.log('📁 预期文件结构:');
        console.log('   📄 cell2.html (当前文件)');
        console.log('   🎬 animation.mp4 (开场动画视频 - 同目录) - ⚠️ 文件缺失');
        console.log('   📁 cell_model1/ (3D模型文件夹) - ⚠️ 文件夹缺失');
        console.log('      🎮 model.gltf/model.glb/model.obj (原核细胞3D模型)');
        console.log('🚫 注意: 不再支持intro1.mp4、intro2.mp4等旧格式视频');
        console.log('⚠️ 提示: 由于缺少媒体文件，将直接进入演示模式');
        
        // 检查fetch是否已被重写
        if (!window.fetchIntercepted) {
            // 标记已拦截
            window.fetchIntercepted = true;
            console.log('✅ fetch拦截器已就位，无需重复设置');
        }
        
        // 阻止video元素加载intro类文件
        document.addEventListener('DOMContentLoaded', function() {
            const video = document.getElementById('intro-video');
            if (video) {
                video.addEventListener('loadstart', function() {
                    if (video.src.includes('intro') && video.src.includes('.mp4')) {
                        console.error('🚫 阻止video元素加载intro类文件:', video.src);
                        video.pause();
                        video.src = '';
                        video.load();
                    }
                });
            }
        });

        // 视频加载界面控制
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 页面加载完成，开始初始化细胞结构3D可视化平台');
            console.log('📋 重要说明: 本平台只会播放animation/animation.mp4，绝不加载intro*.mp4文件');
            
            const videoContainer = document.getElementById('video-container');
            const introVideo = document.getElementById('intro-video');
            const platformTitle = document.getElementById('platform-title');
            const enterButton = document.getElementById('enter-button');
            const mainContainer = document.getElementById('container');
            const loadingIndicator = document.getElementById('loading-indicator');
            
            // 立即清理任何可能的缓存引用
            console.log('🧹 清理video元素状态...');
            introVideo.src = '';
            introVideo.load(); // 重置video元素状态
            introVideo.pause();
            
            // 清理可能的localStorage缓存
            try {
                localStorage.removeItem('lastVideoSrc');
                localStorage.removeItem('introVideos');
                localStorage.removeItem('currentVideoIndex');
                console.log('🗑️  清理localStorage完成');
            } catch (e) {
                console.log('⚠️  清理localStorage失败（可能被禁用）:', e.message);
            }
            
            // 加载并播放视频 - 只播放animation.mp4，绝不加载其他文件
            async function loadAndPlayNextVideo() {
                console.log('=== 开始播放animation.mp4视频 ===');
                console.log('⚠️  重要提示: 只会加载animation.mp4，绝不会加载intro1.mp4等其他文件');
                
                // 明确指定要加载的视频文件名
                const targetVideoFileName = 'animation.mp4';
                
                // 获取当前页面信息
                const currentPath = window.location.pathname;
                const currentHref = window.location.href;
                console.log('当前页面路径:', currentPath);
                console.log('当前页面完整URL:', currentHref);
                
                // 检测HTML文件是否在animation文件夹内
                const isInAnimationFolder = currentPath.includes('/animation/') || 
                                          currentPath.includes('\\animation\\') ||
                                          currentPath.endsWith('/animation') ||
                                          currentPath.endsWith('\\animation');
                
                console.log('是否在animation文件夹内:', isInAnimationFolder);
                
                // 根据HTML文件位置确定视频路径 - HTML和animation.mp4在同一文件夹下
                let videoSrc = targetVideoFileName; // 直接使用文件名
                console.log('HTML和视频文件在同一目录，使用直接路径:', videoSrc);
                
                // 再次确认不会加载错误的文件
                if (videoSrc.includes('intro') || !videoSrc.includes('animation.mp4')) {
                    console.error('❌ 致命错误: 检测到尝试加载非animation.mp4文件:', videoSrc);
                    console.error('❌ 强制修正为正确路径');
                    videoSrc = 'animation.mp4'; // 直接使用同目录下的文件名
                }
                
                // 检查视频文件是否存在
                console.log('开始检测视频文件...');
                try {
                    const exists = await checkVideoExists(videoSrc);
                    if (exists) {
                        console.log(`✓ 找到视频文件: ${videoSrc}`);
                        
                        // 更新加载提示
                        if (loadingIndicator) {
                            loadingIndicator.textContent = '正在播放动画...';
                        }
                        
                        // 开始循环播放视频
                        playVideoLoop(videoSrc);
                    } else {
                        console.log(`✗ 未找到视频文件: ${videoSrc}`);
                        // 启用演示模式
                        enableDemoMode();
                    }
                } catch (error) {
                    console.log(`检测视频失败: ${videoSrc}`, error);
                    enableDemoMode();
                }
            }
            
            // 循环播放视频的函数 - 简化版
            function playVideoLoop(videoSrc) {
                console.log(`开始循环播放视频: ${videoSrc}`);
                
                // 最终安全检查 - 确保不会加载错误的文件
                if (videoSrc.includes('intro') || !videoSrc.includes('animation.mp4')) {
                    console.error('❌ 严重警告: playVideoLoop收到了错误的视频路径:', videoSrc);
                    console.error('❌ 拒绝播放，启用演示模式');
                    enableDemoMode();
                    return;
                }
                
                // 清除video元素的任何现有状态
                introVideo.pause();
                introVideo.src = '';
                introVideo.load(); // 重置
                
                // 设置视频源
                introVideo.src = videoSrc;
                introVideo.currentTime = 0;
                introVideo.loop = true; // 开启循环播放
                introVideo.muted = true; // 确保能自动播放
                introVideo.autoplay = true; // 尝试自动播放
                
                // 简化的事件处理
                introVideo.onloadedmetadata = function() {
                    console.log(`视频元数据加载成功: ${videoSrc}，时长: ${introVideo.duration}秒`);
                    
                    // 立即尝试播放
                    introVideo.play().then(() => {
                        console.log('✓ 开始播放:', videoSrc);
                        
                        // 5秒后显示进入按钮
                        setTimeout(() => {
                            console.log('视频已播放足够时间，显示进入按钮');
                            showTitleAndButton();
                        }, 5000);
                        
                    }).catch(error => {
                        console.log('⚠️ 自动播放失败，用户需要手动交互:', error);
                        // 显示一个提示让用户点击播放
                        setTimeout(() => {
                            showTitleAndButton();
                        }, 2000);
                    });
                };
                
                introVideo.onerror = function(error) {
                    console.log(`✗ 视频播放出错: ${videoSrc}`, error);
                    setTimeout(() => {
                        enableDemoMode();
                    }, 1000);
                };
                
                // 手动触发加载
                introVideo.load();
                
                // 开始播放
                introVideo.play().then(() => {
                    console.log(`✓ 开始循环播放: ${videoSrc}`);
                }).catch(error => {
                    console.log(`✗ 播放启动失败: ${videoSrc}`, error);
                    setTimeout(() => {
                        enableDemoMode();
                    }, 1000);
                });
            }
            
            // 启用演示模式
            function enableDemoMode() {
                console.log('⚠️ 启用演示模式 - 未检测到animation.mp4文件');
                demoModeActive = true;
                
                if (loadingIndicator) {
                    loadingIndicator.innerHTML = `
                        <div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 10px;">🧬 细胞结构3D可视化平台</div>
                            <div style="font-size: 0.9em; opacity: 0.8;">文件缺失，使用演示模式</div>
                            <div style="font-size: 0.8em; opacity: 0.6; margin-top: 5px;">
                                缺少: animation.mp4, cell_model1/<br>
                                🔬 BioDigital API已配置
                            </div>
                            <div style="width: 100%; height: 2px; background: rgba(255,255,255,0.3); margin: 20px 0; border-radius: 1px; overflow: hidden;">
                                <div style="width: 0%; height: 100%; background: linear-gradient(90deg, #4ECDC4, #44A08D); border-radius: 1px; animation: loadingBar 2s ease-in-out forwards;"></div>
                            </div>
                        </div>
                        <style>
                            @keyframes loadingBar {
                                0% { width: 0%; }
                                50% { width: 70%; }
                                100% { width: 100%; }
                            }
                        </style>
                    `;
                }
                
                // 缩短等待时间到2秒
                setTimeout(() => {
                    console.log('⚠️ 演示模式延时完成，显示主界面按钮');
                    allVideosPlayed = true;
                    showTitleAndButton();
                }, 2000);
            }
            
            // 检测视频文件是否存在 - 增强版
            async function checkVideoExists(videoSrc) {
                console.log(`开始检测视频文件: ${videoSrc}`);
                
                // 安全检查 - 绝不检测intro开头的文件
                if (videoSrc.includes('intro') && !videoSrc.includes('animation.mp4')) {
                    console.error('❌ 拒绝检测intro类文件:', videoSrc);
                    return false;
                }
                
                try {
                    // 生成完整URL
                    const fullUrl = new URL(videoSrc, window.location.href);
                    console.log(`完整视频URL: ${fullUrl.href}`);
                    
                    // 使用HEAD请求检测文件，强制刷新缓存
                    const response = await fetch(videoSrc, { 
                        method: 'HEAD',
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                    
                    if (response.ok) {
                        console.log(`✓ 视频文件存在: ${videoSrc} (状态: ${response.status})`);
                        return true;
                    } else {
                        console.log(`✗ 视频文件不存在: ${videoSrc} (状态: ${response.status})`);
                        return false;
                    }
                } catch (error) {
                    console.log(`✗ 检测视频文件失败: ${videoSrc}`, error.message);
                    return false;
                }
            }
            
            // 显示标题和进入按钮
            function showTitleAndButton() {
                console.log('所有视频播放完毕，显示标题和按钮');
                
                // 隐藏加载提示
                if (loadingIndicator) {
                    loadingIndicator.style.opacity = '0';
                    setTimeout(() => {
                        loadingIndicator.style.display = 'none';
                    }, 500);
                }
                
                // 暂停视频
                introVideo.pause();
                
                // 显示标题和按钮（添加渐现效果）
                setTimeout(() => {
                    platformTitle.classList.add('show');
                    setTimeout(() => {
                        enterButton.classList.add('show');
                    }, 800);
                }, 1000);
            }
            
            // 页面加载完成后开始播放视频
            window.addEventListener('load', function() {
                console.log('=== 页面加载完成，开始播放动画 ===');
                console.log('当前页面完整URL:', window.location.href);
                console.log('当前页面路径:', window.location.pathname);
                console.log('当前页面目录:', window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')));
                console.log('当前HTML文件名:', window.location.pathname.substring(window.location.pathname.lastIndexOf('/') + 1));
                
                // 根据您提供的路径信息：
                // HTML: D:\学习资料\微生物学\Cell_Compare\deepseek_html_20250625_795aa2.html
                // 视频: D:\学习资料\微生物学\Cell_Compare\animation\animation.mp4
                // 模型: D:\学习资料\微生物学\Cell_Compare\cell_model1\*
                // 使用相对路径: animation/animation.mp4 和 cell_model1/*
                
                loadAndPlayNextVideo();
                
                // 超时保护：如果8秒内没有成功播放就显示按钮
                setTimeout(() => {
                    if (!allVideosPlayed) {
                        console.log('⏰ 8秒超时保护：强制显示主界面按钮');
                        allVideosPlayed = true;
                        showTitleAndButton();
                    }
                }, 8000);
            });
            
            // 全局状态变量
            let allVideosPlayed = false;
            let demoModeActive = false;
            
            // 进入主界面按钮点击事件
            enterButton.addEventListener('click', function() {
                videoContainer.style.opacity = '0';
                videoContainer.style.transform = 'scale(1.1)';
                
                setTimeout(() => {
                    videoContainer.style.display = 'none';
                    mainContainer.style.display = 'flex';
                    mainContainer.style.opacity = '0';
                    
                    // 淡入主界面
                    setTimeout(() => {
                        mainContainer.style.transition = 'opacity 1s ease';
                        mainContainer.style.opacity = '1';
                        init3DViewer();
                    }, 100);
                }, 500);
            });
        });
        
        // 3D场景初始化
        function init3DViewer() {
            const container = document.getElementById('render-container');
            
            // 场景设置
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x95D4F3); // 使用新的配色方案
            
            // 相机设置
            const camera = new THREE.PerspectiveCamera(75, (container.clientWidth - 300) / container.clientHeight, 0.1, 1000);
            camera.position.z = 30;
            camera.position.y = 10;
            
            // 渲染器设置
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // 控制器设置
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // 光源设置 - 增强照明效果
            const ambientLight = new THREE.AmbientLight(0xF9F2E0, 0.6);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0x3DA4E6, 1.0);
            directionalLight1.position.set(10, 10, 5);
            directionalLight1.castShadow = true;
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0x1660AB, 0.7);
            directionalLight2.position.set(-10, -5, -5);
            scene.add(directionalLight2);
            
            // 添加点光源以增强视觉效果
            const pointLight = new THREE.PointLight(0x95D4F3, 0.8, 100);
            pointLight.position.set(0, 15, 10);
            scene.add(pointLight);
            
            // 存储所有可交互的部分
            const cellParts = {
                prokaryotic: {},
                eukaryotic: {}
            };
            
            // 存储高亮材质
            const highlightMaterials = new Map();
            let currentHighlighted = null;
            
            // 创建3D文字标签
            function createTextLabel(text, position) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                // 使用渐变背景
                const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#F9F2E0');
                gradient.addColorStop(1, '#E2E7BF');
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // 添加边框
                context.strokeStyle = '#1660AB';
                context.lineWidth = 3;
                context.strokeRect(0, 0, canvas.width, canvas.height);
                
                // 添加文字
                context.fillStyle = '#2B313F';
                context.font = 'bold 24px Arial';
                context.textAlign = 'center';
                context.shadowColor = 'rgba(166, 27, 41, 0.3)';
                context.shadowBlur = 4;
                context.shadowOffsetX = 2;
                context.shadowOffsetY = 2;
                context.fillText(text, canvas.width / 2, canvas.height / 2 + 8);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(position);
                sprite.scale.set(8, 2, 1);
                
                return sprite;
            }
            
            // 创建细胞模型
            const cells = {
                prokaryotic: createProkaryoticCell(),
                eukaryotic: createEukaryoticCell()
            };
            
            // 将细胞模型添加到场景
            // 不添加原核细胞到场景，而是用BioDigital模型替代
            // cells.prokaryotic.position.x = -15;
            // scene.add(cells.prokaryotic);
            
            // 使用BioDigital模型替代原核细胞（左侧位置）
            const biodigitalContainer = document.createElement('div');
            biodigitalContainer.id = 'biodigital-prokaryotic-cell';
            biodigitalContainer.style.cssText = `
                position: absolute;
                left: 100px;
                top: 120px;
                width: 480px;
                height: 480px;
                border: 2px solid rgba(249, 242, 224, 0.3);
                border-radius: 16px;
                overflow: hidden;
                background: linear-gradient(135deg, rgba(9, 55, 92, 0.1), rgba(166, 27, 41, 0.05));
                z-index: 10;
                box-shadow: 
                    0 12px 40px rgba(9, 55, 92, 0.3),
                    inset 0 1px 0 rgba(249, 242, 224, 0.2);
                backdrop-filter: blur(5px);
            `;
            
            // 创建iframe（官方推荐方式）
            const iframe = document.createElement('iframe');
            iframe.id = 'biodigital-widget';
            // 使用经过验证的细胞模型ID - 确保模型存在且可访问
            iframe.src = `https://human.biodigital.com/widget/?m=maleAdult&dk=0e068cfbbba1de0aef62cb0f88efc977de83ff6f&ui-info=false&ui-fullscreen=false&ui-help=false&ui-layers=false&ui-search=false&ui-menu=false&ui-tools=false&ui-labels=false&background=transparent`;
            iframe.style.cssText = `
                width: 100%;
                height: 100%;
                border: none;
                border-radius: 14px;
                background: transparent;
            `;
            biodigitalContainer.appendChild(iframe);
            
            // 添加加载指示器
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'biodigital-loading';
            loadingDiv.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #F9F2E0;
                font-size: 16px;
                z-index: 20;
                text-align: center;
                background: rgba(9, 55, 92, 0.8);
                padding: 20px;
                border-radius: 8px;
                backdrop-filter: blur(5px);
            `;
            loadingDiv.innerHTML = `
                <div style="margin-bottom: 10px;">🔬 加载BioDigital细胞模型</div>
                <div style="font-size: 12px; opacity: 0.8;">请稍候...</div>
            `;
            biodigitalContainer.appendChild(loadingDiv);
            
            // 等待iframe加载后隐藏加载指示器
            iframe.addEventListener('load', () => {
                setTimeout(() => {
                    loadingDiv.style.display = 'none';
                }, 1000);
            });
            
            // 添加到场景容器
            container.appendChild(biodigitalContainer);
            
            // 等待iframe加载完成后初始化API
            iframe.onload = function() {
                // 等待HumanAPI脚本完全加载
                function initBioDigitalAPI() {
                    if (typeof HumanAPI !== 'undefined') {
                        try {
                            window.humanAPI = new HumanAPI("biodigital-widget");
                            console.log('✅ BioDigital HumanAPI 初始化成功！');
                            
                            // 等待更长时间确保模型完全加载
                            setTimeout(() => {
                                if (window.humanAPI) {
                                    try {
                                        window.humanAPI.send("timeline.pause");
                                        window.humanAPI.send("camera.set", {
                                            position: { x: 0, y: 0, z: -50 },
                                            target: { x: 0, y: 0, z: 0 },
                                            animate: true
                                        });
                                        window.humanAPI.send("scene.set", {
                                            background: { r: 0.58, g: 0.83, b: 0.95, a: 0.1 } // 透明背景
                                        });
                                        console.log('🔬 BioDigital模型已配置为细胞展示模式');
                                    } catch (configError) {
                                        console.log('⚠️ BioDigital配置失败（模型仍可用）:', configError);
                                    }
                                }
                            }, 3000);
                            
                        } catch (error) {
                            console.error('❌ BioDigital HumanAPI 初始化失败:', error);
                            fallbackToThreeJS();
                        }
                    } else {
                        // HumanAPI还没加载，稍后重试
                        console.log('⏳ 等待HumanAPI脚本加载...');
                        setTimeout(initBioDigitalAPI, 500);
                    }
                }
                
                // 开始初始化
                initBioDigitalAPI();
            };
            
            // iframe加载失败的处理
            iframe.onerror = function() {
                console.error('❌ BioDigital iframe加载失败');
                fallbackToThreeJS();
            };
            
            // iframe网络错误的额外监听
            iframe.addEventListener('error', function() {
                console.error('❌ BioDigital模型加载错误');
                fallbackToThreeJS();
            });
            
            // 超时保护 - 如果3秒内没有成功加载就使用备用模型
            setTimeout(() => {
                if (!window.humanAPI) {
                    console.log('⏰ BioDigital加载超时，使用备用模型');
                    fallbackToThreeJS();
                }
            }, 3000);
            
            // 备用方案函数
            function fallbackToThreeJS() {
                cells.prokaryotic.position.x = -15;
                scene.add(cells.prokaryotic);
                biodigitalContainer.style.display = 'none';
                console.log('🔄 使用备用Three.js原核细胞模型');
            }
            
            // 原来的Three.js真核细胞模型（备用）
            cells.eukaryotic.position.x = 15;
            cells.eukaryotic.visible = false; // 隐藏原模型
            scene.add(cells.eukaryotic);
            
            // 创建3D标签
            const prokaryoticLabel = createTextLabel('原核细胞 (BioDigital)', new THREE.Vector3(-15, 12, 0));
            const eukaryoticLabel = createTextLabel('真核细胞', new THREE.Vector3(15, 12, 0));
            scene.add(prokaryoticLabel);
            scene.add(eukaryoticLabel);
            
            // 高亮功能
            function highlightPart(cellType, partName) {
                // 清除之前的高亮
                clearHighlight();
                
                if (cellParts[cellType] && cellParts[cellType][partName]) {
                    const part = cellParts[cellType][partName];
                    currentHighlighted = { cellType, partName, part };
                    
                    if (part instanceof THREE.Group) {
                        part.children.forEach(child => {
                            if (child.material) {
                                const originalMaterial = child.material;
                                const highlightMaterial = originalMaterial.clone();
                                // 使用新配色的发光效果
                                highlightMaterial.emissive = new THREE.Color(0xA61B29);
                                highlightMaterial.emissiveIntensity = 0.3;
                                highlightMaterials.set(child, originalMaterial);
                                child.material = highlightMaterial;
                            }
                        });
                    } else if (part.material) {
                        const originalMaterial = part.material;
                        const highlightMaterial = originalMaterial.clone();
                        highlightMaterial.emissive = new THREE.Color(0xA61B29);
                        highlightMaterial.emissiveIntensity = 0.3;
                        highlightMaterials.set(part, originalMaterial);
                        part.material = highlightMaterial;
                    }
                }
            }
            
            function clearHighlight() {
                if (currentHighlighted) {
                    highlightMaterials.forEach((originalMaterial, object) => {
                        object.material = originalMaterial;
                    });
                    highlightMaterials.clear();
                    currentHighlighted = null;
                }
            }
            
// 创建原核细胞 - 使用外部3D模型
function createProkaryoticCell() {
    const group = new THREE.Group();
    
    // 创建一个加载中的占位符
    const placeholderGeometry = new THREE.SphereGeometry(5, 16, 16);
    const placeholderMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x888888, 
        transparent: true, 
        opacity: 0.3,
        wireframe: true 
    });
    const placeholder = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
    group.add(placeholder);
    
    // 添加加载文本
    const loader = new THREE.FontLoader();
    
    // 创建简单的文本标识
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 64;
    
    context.fillStyle = '#333333';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    context.fillStyle = '#ffffff';
    context.font = 'bold 20px Arial';
    context.textAlign = 'center';
    context.fillText('正在加载原核细胞模型...', canvas.width / 2, canvas.height / 2 + 7);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.set(0, 8, 0);
    sprite.scale.set(8, 2, 1);
    group.add(sprite);
    
    // 使用GLTFLoader和OBJLoader加载外部模型
    const gltfLoader = new THREE.GLTFLoader();
    const objLoader = new THREE.OBJLoader();
    
    // 尝试加载不同的可能文件格式
    const possibleModels = [
        { path: 'cell_model1/model.obj', type: 'obj' },
        { path: 'cell_model1/model.gltf', type: 'gltf' },
        { path: 'cell_model1/model.glb', type: 'gltf' },
        { path: 'cell_model1/prokaryotic_cell.obj', type: 'obj' },
        { path: 'cell_model1/prokaryotic_cell.gltf', type: 'gltf' },
        { path: 'cell_model1/prokaryotic_cell.glb', type: 'gltf' },
        { path: 'cell_model1/prokaryotic.obj', type: 'obj' },
        { path: 'cell_model1/prokaryotic.gltf', type: 'gltf' },
        { path: 'cell_model1/prokaryotic.glb', type: 'gltf' }
    ];
    
    let modelLoaded = false;
    
    function tryLoadModel(modelIndex = 0) {
        if (modelIndex >= possibleModels.length) {
            console.log('⚠️ 未找到可用的原核细胞模型，使用内置模型');
            // 移除占位符和加载文本
            group.remove(placeholder);
            group.remove(sprite);
            // 创建简化的内置模型
            createFallbackProkaryoticCell(group);
            return;
        }
        
        const modelInfo = possibleModels[modelIndex];
        const modelPath = modelInfo.path;
        console.log(`尝试加载原核细胞模型: ${modelPath} (类型: ${modelInfo.type})`);
        
        // 更新加载文本
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = '#333333';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = '#ffffff';
        context.fillText(`加载模型 ${modelIndex + 1}/${possibleModels.length}...`, canvas.width / 2, canvas.height / 2 + 7);
        texture.needsUpdate = true;
        
        // 根据模型类型选择加载器
        if (modelInfo.type === 'gltf') {
            gltfLoader.load(
                modelPath,
            function(gltf) {
                console.log(`✓ 成功加载原核细胞模型: ${modelPath}`);
                modelLoaded = true;
                
                // 移除占位符
                group.remove(placeholder);
                group.remove(sprite);
                
                // 添加加载的模型
                const model = gltf.scene;
                
                // 调整模型大小和位置
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                
                // 缩放模型使其适合场景
                const maxSize = Math.max(size.x, size.y, size.z);
                const targetSize = 10; // 目标大小
                const scale = targetSize / maxSize;
                model.scale.setScalar(scale);
                
                // 居中模型
                model.position.sub(center.multiplyScalar(scale));
                
                // 应用材质增强
                model.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // 增强材质
                        if (child.material) {
                            child.material.needsUpdate = true;
                            
                            // 为不同部分设置不同的材质属性
                            if (child.name.toLowerCase().includes('membrane') || 
                                child.name.toLowerCase().includes('膜')) {
                                child.material.transparent = true;
                                child.material.opacity = 0.7;
                                child.material.color.setHex(0x00aa00);
                                cellParts.prokaryotic.cellMembrane = child;
                            } else if (child.name.toLowerCase().includes('wall') || 
                                      child.name.toLowerCase().includes('壁')) {
                                child.material.transparent = true;
                                child.material.opacity = 0.5;
                                child.material.color.setHex(0xcccccc);
                                cellParts.prokaryotic.cellWall = child;
                            } else if (child.name.toLowerCase().includes('nucleoid') || 
                                      child.name.toLowerCase().includes('核')) {
                                child.material.color.setHex(0x0000aa);
                                cellParts.prokaryotic.nucleoid = child;
                            } else if (child.name.toLowerCase().includes('ribosome') || 
                                      child.name.toLowerCase().includes('核糖体')) {
                                child.material.color.setHex(0x555555);
                                cellParts.prokaryotic.ribosomes = child;
                            }
                        }
                    }
                });
                
                group.add(model);
                console.log('原核细胞模型加载完成');
            },
            function(progress) {
                console.log(`加载进度: ${modelPath} - ${(progress.loaded / progress.total * 100)}%`);
            },
            function(error) {
                console.log(`✗ 加载GLTF模型失败: ${modelPath}`, error);
                // 尝试下一个模型
                setTimeout(() => tryLoadModel(modelIndex + 1), 100);
            }
        );
        } else if (modelInfo.type === 'obj') {
            // 使用OBJ加载器
            objLoader.load(
                modelPath,
                function(object) {
                    console.log(`✓ 成功加载原核细胞OBJ模型: ${modelPath}`);
                    modelLoaded = true;
                    
                    // 移除占位符
                    group.remove(placeholder);
                    group.remove(sprite);
                    
                    // 调整模型大小和位置
                    const box = new THREE.Box3().setFromObject(object);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());
                    
                    // 缩放模型使其适合场景
                    const maxSize = Math.max(size.x, size.y, size.z);
                    const targetSize = 10; // 目标大小
                    const scale = targetSize / maxSize;
                    object.scale.setScalar(scale);
                    
                    // 居中模型
                    object.position.sub(center.multiplyScalar(scale));
                    
                    // 应用默认材质
                    object.traverse(function(child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // 如果没有材质，添加默认材质
                            if (!child.material) {
                                child.material = new THREE.MeshPhongMaterial({ 
                                    color: 0x88ccff,
                                    transparent: true,
                                    opacity: 0.8
                                });
                            }
                        }
                    });
                    
                    group.add(object);
                    console.log('原核细胞OBJ模型加载完成');
                },
                function(progress) {
                    console.log(`OBJ加载进度: ${modelPath}`);
                },
                function(error) {
                    console.log(`✗ 加载OBJ模型失败: ${modelPath}`, error);
                    // 尝试下一个模型
                    setTimeout(() => tryLoadModel(modelIndex + 1), 100);
                }
            );
        }
    }
    
    // 开始加载模型
    tryLoadModel();
    
    return group;
}

// 创建备用的原核细胞模型（简化版）
function createFallbackProkaryoticCell(group) {
    console.log('创建备用原核细胞模型');
    
    // 细胞质基质（半透明）
    const cytoplasmGeometry = new THREE.SphereGeometry(6, 32, 32);
    const cytoplasmMaterial = new THREE.MeshPhongMaterial({
        color: 0xffe4b5,
        transparent: true,
        opacity: 0.3
    });
    const cytoplasm = new THREE.Mesh(cytoplasmGeometry, cytoplasmMaterial);
    group.add(cytoplasm);
    cellParts.prokaryotic.cytoplasm = cytoplasm;

    // 细胞膜
    const cellMembraneGeometry = new THREE.SphereGeometry(6.2, 32, 32);
    const cellMembraneMaterial = new THREE.MeshPhongMaterial({
        color: 0x00aa00,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide
    });
    const cellMembrane = new THREE.Mesh(cellMembraneGeometry, cellMembraneMaterial);
    group.add(cellMembrane);
    cellParts.prokaryotic.cellMembrane = cellMembrane;

    // 细胞壁
    const cellWallGeometry = new THREE.SphereGeometry(6.5, 32, 32);
    const cellWallMaterial = new THREE.MeshPhongMaterial({
        color: 0xcccccc,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide
    });
    const cellWall = new THREE.Mesh(cellWallGeometry, cellWallMaterial);
    group.add(cellWall);
    cellParts.prokaryotic.cellWall = cellWall;

    // 拟核
    const nucleoidGeometry = new THREE.TorusKnotGeometry(1.5, 0.2, 100, 16);
    const nucleoidMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x0000aa, 
        transparent: true, 
        opacity: 0.7 
    });
    const nucleoid = new THREE.Mesh(nucleoidGeometry, nucleoidMaterial);
    nucleoid.position.set(0, 0, 0);
    group.add(nucleoid);
    cellParts.prokaryotic.nucleoid = nucleoid;

    // 核糖体群
    const ribosomesGroup = new THREE.Group();
    for (let i = 0; i < 20; i++) {
        const ribosomeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const ribosomeMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
        const ribosome = new THREE.Mesh(ribosomeGeometry, ribosomeMaterial);

        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const radius = 3 + Math.random() * 2;

        ribosome.position.set(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi)
        );

        ribosomesGroup.add(ribosome);
    }
    group.add(ribosomesGroup);
    cellParts.prokaryotic.ribosomes = ribosomesGroup;
}

// 创建真核细胞
function createEukaryoticCell() {
                const group = new THREE.Group();
                
                // 细胞质基质（半透明）
                const cytoplasmGeometry = new THREE.SphereGeometry(8, 32, 32);
                const cytoplasmMaterial = new THREE.MeshPhongMaterial({
                    color: 0x88ccff,
                    transparent: true,
                    opacity: 0.3
                });
                const cytoplasm = new THREE.Mesh(cytoplasmGeometry, cytoplasmMaterial);
                group.add(cytoplasm);
                cellParts.eukaryotic.cytoplasm = cytoplasm;
                
                // 细胞膜
                const cellMembraneGeometry = new THREE.SphereGeometry(8.2, 32, 32);
                const cellMembraneMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00aa00,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const cellMembrane = new THREE.Mesh(cellMembraneGeometry, cellMembraneMaterial);
                group.add(cellMembrane);
                cellParts.eukaryotic.cellMembrane = cellMembrane;
                
                // 植物细胞壁（用于对比）
                const plantCellWallGeometry = new THREE.SphereGeometry(8.4, 32, 32);
                const plantCellWallMaterial = new THREE.MeshPhongMaterial({
                    color: 0x90EE90,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const plantCellWall = new THREE.Mesh(plantCellWallGeometry, plantCellWallMaterial);
                group.add(plantCellWall);
                cellParts.eukaryotic.cellWall = plantCellWall;
                
                // 细胞核
                const nucleusGeometry = new THREE.SphereGeometry(2.5, 32, 32);
                const nucleusMaterial = new THREE.MeshPhongMaterial({
                    color: 0xaa0000,
                    transparent: true,
                    opacity: 0.7
                });
                const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
                nucleus.position.set(0, 0, 0);
                group.add(nucleus);
                cellParts.eukaryotic.nucleus = nucleus;
                
                // 核膜
                const nuclearMembraneGeometry = new THREE.SphereGeometry(2.7, 32, 32);
                const nuclearMembraneMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00aa00,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const nuclearMembrane = new THREE.Mesh(nuclearMembraneGeometry, nuclearMembraneMaterial);
                group.add(nuclearMembrane);
                cellParts.eukaryotic.nuclearMembrane = nuclearMembrane;
                
                // 核仁
                const nucleolusGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const nucleolusMaterial = new THREE.MeshPhongMaterial({ color: 0xdd0000 });
                const nucleolus = new THREE.Mesh(nucleolusGeometry, nucleolusMaterial);
                nucleolus.position.set(1, 0.5, 0.5);
                nucleus.add(nucleolus);
                cellParts.eukaryotic.nucleolus = nucleolus;
                
                // 线粒体（多个）
                const mitochondriaGroup = new THREE.Group();
                for (let i = 0; i < 5; i++) {
                    const mitochondrionGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                    const mitochondrionMaterial = new THREE.MeshPhongMaterial({ color: 0x00aa77 });
                    const mitochondrion = new THREE.Mesh(mitochondrionGeometry, mitochondrionMaterial);
                    
                    // 随机分布在细胞质中
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 5 + 2 * Math.random();
                    
                    mitochondrion.position.set(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    );
                    
                    // 添加内膜褶皱效果
                    const innerMembraneGeometry = new THREE.TorusGeometry(0.6, 0.1, 8, 16);
                    const innerMembraneMaterial = new THREE.MeshPhongMaterial({ color: 0x007755 });
                    
                    for (let j = 0; j < 5; j++) {
                        const innerMembrane = new THREE.Mesh(innerMembraneGeometry, innerMembraneMaterial);
                        innerMembrane.rotation.x = Math.random() * Math.PI;
                        innerMembrane.rotation.y = Math.random() * Math.PI;
                        innerMembrane.position.set(
                            (Math.random() - 0.5) * 0.4,
                            (Math.random() - 0.5) * 0.4,
                            (Math.random() - 0.5) * 0.4
                        );
                        mitochondrion.add(innerMembrane);
                    }
                    
                    mitochondriaGroup.add(mitochondrion);
                }
                group.add(mitochondriaGroup);
                cellParts.eukaryotic.mitochondria = mitochondriaGroup;
                
                // 内质网（粗糙和光滑）
                const erGroup = new THREE.Group();
                
                // 粗糙内质网（带核糖体）
                const roughErGeometry = new THREE.TorusKnotGeometry(2, 0.3, 100, 16);
                const roughErMaterial = new THREE.MeshPhongMaterial({ color: 0x5555ff });
                const roughEr = new THREE.Mesh(roughErGeometry, roughErMaterial);
                roughEr.position.set(3, 2, 0);
                roughEr.rotation.set(Math.PI/4, Math.PI/4, 0);
                erGroup.add(roughEr);
                
                // 添加核糖体到粗糙内质网
                for (let i = 0; i < 20; i++) {
                    const ribosomeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const ribosomeMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
                    const ribosome = new THREE.Mesh(ribosomeGeometry, ribosomeMaterial);
                    
                    // 随机分布在粗糙内质网周围
                    const angle = (i / 20) * Math.PI * 2;
                    const radius = 2.5 + Math.random() * 0.5;
                    ribosome.position.set(
                        3 + radius * Math.cos(angle),
                        2 + radius * Math.sin(angle),
                        (Math.random() - 0.5) * 1
                    );
                    
                    erGroup.add(ribosome);
                }
                
                // 光滑内质网
                const smoothErGeometry = new THREE.TorusKnotGeometry(1.8, 0.3, 100, 16);
                const smoothErMaterial = new THREE.MeshPhongMaterial({ color: 0x8888ff });
                const smoothEr = new THREE.Mesh(smoothErGeometry, smoothErMaterial);
                smoothEr.position.set(-2, -1, 2);
                smoothEr.rotation.set(Math.PI/3, Math.PI/3, 0);
                erGroup.add(smoothEr);
                
                group.add(erGroup);
                cellParts.eukaryotic.endoplasmicReticulum = erGroup;
                
                // 高尔基体
                const golgiGroup = new THREE.Group();
                
                // 高尔基体由多个扁平的囊泡组成
                for (let i = 0; i < 5; i++) {
                    const golgiCisternaGeometry = new THREE.TorusGeometry(1.5 - i * 0.2, 0.3, 8, 16);
                    const golgiCisternaMaterial = new THREE.MeshPhongMaterial({ color: 0xffaa00 });
                    const golgiCisterna = new THREE.Mesh(golgiCisternaGeometry, golgiCisternaMaterial);
                    golgiCisterna.position.set(-3, 3, 0);
                    golgiCisterna.rotation.x = Math.PI / 2;
                    golgiCisterna.rotation.z = i * 0.1;
                    golgiGroup.add(golgiCisterna);
                }
                
                group.add(golgiGroup);
                cellParts.eukaryotic.golgiApparatus = golgiGroup;
                
                // 溶酶体
                const lysosomeGeometry = new THREE.SphereGeometry(0.7, 16, 16);
                const lysosomeMaterial = new THREE.MeshPhongMaterial({ color: 0xff5555 });
                const lysosome = new THREE.Mesh(lysosomeGeometry, lysosomeMaterial);
                lysosome.position.set(2, -3, 1);
                group.add(lysosome);
                cellParts.eukaryotic.lysosomes = lysosome;
                
                // 核糖体（游离在细胞质中的）
                const ribosomesGroup = new THREE.Group();
                for (let i = 0; i < 50; i++) {
                    const ribosomeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const ribosomeMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
                    const ribosome = new THREE.Mesh(ribosomeGeometry, ribosomeMaterial);
                    
                    // 随机分布在细胞质中，避开细胞核区域
                    let position;
                    do {
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const radius = 6 * Math.random();
                        
                        position = new THREE.Vector3(
                            radius * Math.sin(phi) * Math.cos(theta),
                            radius * Math.sin(phi) * Math.sin(theta),
                            radius * Math.cos(phi)
                        );
                    } while (position.length() < 3); // 确保不在细胞核内
                    
                    ribosome.position.copy(position);
                    ribosomesGroup.add(ribosome);
                }
                group.add(ribosomesGroup);
                cellParts.eukaryotic.ribosomes = ribosomesGroup;
                
                return group;
            }
            
            // BioDigital API集成功能 - 官方推荐方式
            function setupBioDigitalModel() {
                console.log('🧬 开始设置BioDigital HumanAPI模型（官方方式）');
                // 这个函数现在由主初始化代码中的iframe方式替代
                // 参考：https://developer.biodigital.com/documentation/
            }
            
            // 使元素可拖拽
            function makeDraggable(element) {
                let isDragging = false;
                let startX, startY, initialX, initialY;
                
                const title = element.querySelector('div');
                title.style.cursor = 'move';
                
                title.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = element.getBoundingClientRect();
                    initialX = rect.left;
                    initialY = rect.top;
                    element.style.transition = 'none';
                });
                
                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    element.style.left = (initialX + deltaX) + 'px';
                    element.style.top = (initialY + deltaY) + 'px';
                    element.style.right = 'auto';
                });
                
                document.addEventListener('mouseup', function() {
                    if (isDragging) {
                        isDragging = false;
                        element.style.transition = 'all 0.3s ease';
                    }
                });
            }
            
            // 简化的测试函数（仅用于调试）
            window.testBioDigitalAPI = function() {
                console.log('🧪 测试BioDigital HumanAPI连接...');
                
                if (typeof HumanAPI === 'undefined') {
                    console.log('❌ BioDigital HumanAPI脚本未加载！');
                    return;
                }
                
                if (window.humanAPI) {
                    try {
                        window.humanAPI.send("timeline.pause");
                        console.log('✅ BioDigital HumanAPI工作正常！');
                    } catch (error) {
                        console.log('❌ HumanAPI命令失败: ' + error.message);
                    }
                } else {
                    console.log('⚠️ HumanAPI尚未初始化，请等待iframe加载完成');
                }
            };
            

            
            // 动量控制
            let velocity = new THREE.Vector3();
            let direction = new THREE.Vector3();
            let targetRotation = new THREE.Vector3();
            let targetPosition = new THREE.Vector3();
            let isMoving = false;
            
            // 更新控制器
            function updateControls() {
                const delta = 0.1; // 控制移动和旋转的速度因子
                
                // 计算目标旋转
                targetRotation.x = camera.position.y * 0.1;
                targetRotation.y = camera.position.x * 0.1;
                
                // 计算目标位置
                targetPosition.x = Math.sin(Date.now() * 0.001) * 10;
                targetPosition.z = Math.cos(Date.now() * 0.001) * 10;
                
                // 更新相机位置和旋转
                camera.position.lerp(targetPosition, delta);
                camera.rotation.x += (targetRotation.x - camera.rotation.x) * delta;
                camera.rotation.y += (targetRotation.y - camera.rotation.y) * delta;
                
                camera.lookAt(0, 0, 0);
            }
            
            // 动画循环
            function animate() {
                requestAnimationFrame(animate);
                
                // 完全移除自动旋转和自动移动 - 只允许用户手动控制
                // cells.prokaryotic.rotation.y += 0.002;
                // cells.eukaryotic.rotation.y += 0.001;
                
                // 更新标签位置
                prokaryoticLabel.position.copy(cells.prokaryotic.position);
                prokaryoticLabel.position.y += 12;
                
                eukaryoticLabel.position.copy(cells.eukaryotic.position);
                eukaryoticLabel.position.y += 12;
                
                // 不再调用updateControls() - 完全禁用自动相机移动
                // updateControls();
                
                controls.update();
                renderer.render(scene, camera);
            }
            
            animate();
        }
        
        // 在页面加载完成后的处理（移除了部署指导）
        window.addEventListener('load', () => {
            console.log('✅ 页面加载完成，跳过部署指导提示');
        });
    </script>
</body>
</html>